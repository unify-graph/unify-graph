<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Epstein Network — CUE Investigation Model</title>
<meta name="description" content="Open investigation model of the Epstein network. 132 entities, 398 connections, gap analysis, exposure cascades. Built with CUE and D3.">
<meta property="og:title" content="Epstein Network — CUE Investigation Model">
<meta property="og:description" content="132 entities, 398 connections. CUE's type system surfaces investigative gaps as structured data — dangling references, missing evidence, type inconsistencies.">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Epstein Network — CUE Investigation Model">
<meta name="twitter:description" content="Open investigation model. Gap analysis, sole connectors, exposure cascades. Data-first, computation in CUE.">
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; background: #0a0a0f; color: #c8c8d0; font-size: 13px; overflow: hidden; height: 100vh; }
a { color: #6ea8fe; }

/* Layout */
.app { display: grid; grid-template-rows: auto auto 1fr; height: 100vh; }
header { padding: 8px 16px; background: #12121a; border-bottom: 1px solid #2a2a3a; display: flex; justify-content: space-between; align-items: center; }
header h1 { font-size: 14px; font-weight: 600; color: #e8e8f0; }
.stats { display: flex; gap: 16px; font-size: 11px; color: #888; }
.stats .stat { display: flex; gap: 4px; }
.stats .stat-val { color: #6ea8fe; font-weight: 600; }
.stats .stat-bad { color: #f85149; }

nav { display: flex; gap: 2px; padding: 4px 16px; background: #12121a; border-bottom: 1px solid #2a2a3a; }
nav button { background: #1a1a2a; border: 1px solid #2a2a3a; color: #888; padding: 4px 12px; cursor: pointer; font-family: inherit; font-size: 11px; border-radius: 3px; }
nav button.active { background: #2a2a4a; color: #e8e8f0; border-color: #4a4a6a; }
nav button:hover { background: #2a2a3a; }

.main { display: grid; overflow: hidden; }
.main.graph-mode { grid-template-columns: 1fr 380px; }
.main.dash-mode { grid-template-columns: 1fr; }

/* Search */
.search-box { position: relative; }
.search-box input { background: #1a1a2a; border: 1px solid #2a2a3a; color: #e8e8f0; padding: 4px 8px; font-family: inherit; font-size: 11px; border-radius: 3px; width: 200px; }
.search-box input::placeholder { color: #555; }

/* Graph */
#graph-container { overflow: hidden; background: #0a0a0f; position: relative; }
#graph-container svg { width: 100%; height: 100%; }
.node circle { cursor: pointer; stroke-width: 1.5; }
.node text { font-size: 9px; fill: #888; pointer-events: none; }
.node.selected circle { stroke: #fff !important; stroke-width: 3; }
.link { stroke-opacity: 0.4; }
.link.bidirectional { stroke-opacity: 0.6; }
.link.highlighted { stroke-opacity: 1; stroke-width: 3 !important; }

/* Inspector */
#inspector { background: #12121a; border-left: 1px solid #2a2a3a; overflow-y: auto; padding: 12px; }
#inspector.empty { display: flex; align-items: center; justify-content: center; color: #555; font-style: italic; }
.inspector-section { margin-bottom: 16px; }
.inspector-section h3 { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #6ea8fe; margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid #2a2a3a; }
.inspector-section.missing h3 { color: #f85149; }
.inspector-section.leads h3 { color: #f0ad4e; }
.field { display: flex; gap: 8px; margin-bottom: 4px; }
.field-label { color: #666; min-width: 110px; flex-shrink: 0; }
.field-value { color: #c8c8d0; word-break: break-word; }
.badge { display: inline-block; padding: 1px 6px; border-radius: 2px; font-size: 10px; margin: 1px; }
.badge-cluster { background: #1a1a3a; border: 1px solid #3a3a5a; }
.badge-type { background: #1a2a1a; border: 1px solid #3a5a3a; color: #8fbc8f; }
.badge-gap { background: #2a1a1a; border: 1px solid #5a3a3a; color: #f85149; }
.badge-bridge { background: #2a2a1a; border: 1px solid #5a5a3a; color: #f0ad4e; }
.conn-list { list-style: none; }
.conn-list li { padding: 2px 0; cursor: pointer; }
.conn-list li:hover { color: #6ea8fe; }
.conn-list .bidir::before { content: '↔ '; color: #4caf50; }
.conn-list .unidir-out::before { content: '→ '; color: #f0ad4e; }
.conn-list .unidir-in::before { content: '← '; color: #888; }
.entity-name { font-weight: 600; font-size: 16px; color: #e8e8f0; margin-bottom: 4px; }
.entity-id { font-size: 11px; color: #555; margin-bottom: 12px; }

/* Dashboard */
#dashboard { overflow-y: auto; padding: 16px; display: none; }
.dash-header { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
.dash-filter { background: #1a1a2a; border: 1px solid #2a2a3a; color: #888; padding: 4px 10px; cursor: pointer; font-family: inherit; font-size: 11px; border-radius: 3px; }
.dash-filter.active { background: #2a2a4a; color: #e8e8f0; border-color: #4a4a6a; }
.dash-filter .count { color: #6ea8fe; margin-left: 4px; }
table { width: 100%; border-collapse: collapse; font-size: 12px; }
th { text-align: left; padding: 6px 8px; color: #888; border-bottom: 1px solid #2a2a3a; cursor: pointer; user-select: none; position: sticky; top: 0; background: #0a0a0f; }
th:hover { color: #e8e8f0; }
td { padding: 5px 8px; border-bottom: 1px solid #1a1a2a; }
tr:hover { background: #1a1a2a; }
tr.clickable { cursor: pointer; }
.gap-pill { display: inline-block; padding: 1px 5px; border-radius: 2px; font-size: 10px; margin: 1px; }
.gap-missing_evidence { background: #2a1a1a; color: #f85149; }
.gap-orphan { background: #2a2a1a; color: #f0ad4e; }
.gap-cluster_isolated { background: #1a1a2a; color: #6ea8fe; }
.gap-type_inconsistent { background: #2a1a2a; color: #d68fd6; }

/* Cluster colors */
.cluster-core { color: #ff6b6b; }
.cluster-financial { color: #4ecdc4; }
.cluster-hedge_fund { color: #45b7d1; }
.cluster-paypal_mafia { color: #96ceb4; }
.cluster-crypto { color: #ffeaa7; }
.cluster-allegations { color: #ff7675; }
.cluster-political { color: #74b9ff; }
.cluster-cabinet { color: #a29bfe; }
.cluster-legal { color: #fd79a8; }
.cluster-doj { color: #e17055; }
.cluster-shell { color: #636e72; }
.cluster-academia { color: #00b894; }
.cluster-media { color: #fdcb6e; }
.cluster-banking { color: #00cec9; }
.cluster-victim { color: #d63031; }
.cluster-intelligence { color: #6c5ce7; }
.cluster-tech { color: #0984e3; }
.cluster-staff { color: #b2bec3; }
.cluster-family { color: #e84393; }
.cluster-unclassified { color: #636e72; }

/* Legend */
.legend { position: absolute; bottom: 10px; left: 10px; background: rgba(18,18,26,0.9); padding: 8px; border-radius: 4px; border: 1px solid #2a2a3a; font-size: 10px; display: flex; flex-wrap: wrap; gap: 6px; max-width: 500px; }
.legend-item { display: flex; align-items: center; gap: 3px; }
.legend-dot { width: 8px; height: 8px; border-radius: 50%; }

/* Graph controls */
.graph-controls { position: absolute; top: 10px; left: 10px; display: flex; gap: 4px; z-index: 10; }
.graph-controls button { background: rgba(26,26,42,0.9); border: 1px solid #2a2a3a; color: #888; padding: 3px 8px; cursor: pointer; font-family: inherit; font-size: 10px; border-radius: 3px; }
.graph-controls button.active { background: #2a2a4a; color: #e8e8f0; border-color: #4a4a6a; }
.graph-controls button:hover { color: #c8c8d0; }

/* Tooltip */
.tooltip { position: absolute; background: #1a1a2a; border: 1px solid #3a3a5a; padding: 6px 10px; border-radius: 4px; pointer-events: none; font-size: 11px; z-index: 100; white-space: nowrap; }

/* Loading / Error */
#loading { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: #0a0a0f; z-index: 200; flex-direction: column; gap: 12px; }
#loading .spinner { width: 32px; height: 32px; border: 3px solid #2a2a3a; border-top-color: #6ea8fe; border-radius: 50%; animation: spin 0.8s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
#loading .load-text { color: #888; font-size: 12px; }
.error-banner { background: #2a1a1a; border: 1px solid #5a3a3a; color: #f85149; padding: 12px 16px; margin: 16px; border-radius: 4px; }
</style>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Dataset",
  "name": "Epstein Network Investigation Model",
  "description": "CUE-typed investigation model of the Jeffrey Epstein network. 132 entities, 398 connections across 19 clusters. Emphasizes structural gaps and missing evidence rather than known connections.",
  "url": "https://unify-graph.github.io/unify-graph/",
  "license": "https://creativecommons.org/licenses/by/4.0/",
  "creator": {
    "@type": "Organization",
    "name": "unify-graph",
    "url": "https://github.com/unify-graph/unify-graph"
  },
  "distribution": [
    {
      "@type": "DataDownload",
      "encodingFormat": "application/json",
      "contentUrl": "https://unify-graph.github.io/unify-graph/data/graph.json"
    },
    {
      "@type": "DataDownload",
      "encodingFormat": "application/ld+json",
      "contentUrl": "https://unify-graph.github.io/unify-graph/data/context.jsonld"
    }
  ],
  "temporalCoverage": "1993/2026",
  "spatialCoverage": "Global",
  "keywords": ["Epstein", "network analysis", "investigation", "gap analysis", "CUE", "knowledge graph"]
}
</script>

</head>
<body>
<div id="loading"><div class="spinner"></div><div class="load-text">Loading 132 entities...</div></div>
<div class="app">
  <header>
    <h1>Epstein Network — CUE Investigation Model</h1>
    <div class="stats" id="stats"></div>
    <div style="display:flex;gap:8px;align-items:center">
      <div class="search-box">
        <input type="text" id="search" placeholder="Search entities...">
      </div>
      <button id="about-btn" style="background:none;border:1px solid #2a2a3a;color:#888;padding:3px 8px;cursor:pointer;font-family:inherit;font-size:11px;border-radius:3px" title="About this project">?</button>
    </div>
  </header>
  <div id="about-panel" style="display:none;padding:12px 16px;background:#12121a;border-bottom:1px solid #2a2a3a;font-size:12px;line-height:1.6;color:#999">
    <strong style="color:#e8e8f0">What is this?</strong> Most Epstein network projects show what's known — who's connected, what documents mention whom.
    This one measures <em>what's missing</em>. It uses <a href="https://cuelang.org">CUE</a>'s type system as an investigative tool:
    schema violations become leads. Dangling references = unknown persons. Missing evidence = unverified claims.
    Type inconsistencies = logical gaps. All analysis is pre-computed at export time — the browser renders static JSON.
    <br><br>
    <strong style="color:#e8e8f0">Current state:</strong> 132 entities, 398 connections. Evidence coverage is intentionally low (11.4%) — most entities
    were added from structural relationships before evidence was linked. The gap is the work queue, not a surprise.
    The structural analysis is more revealing: most cross-cluster relationships depend on a single bridge entity.
    Discredit that person and the connection between those worlds disappears from the public record.
    <br><br>
    <strong style="color:#e8e8f0">Reading the graph:</strong> Node size = degree. Opacity = evidence (opaque = documented, ghost = unverified).
    Red/orange rings = gap severity. Solid lines = bidirectional. Dashed = one-way claims.
    Toggle buttons switch between manual <strong style="color:#e8e8f0">Clusters</strong> (19 curated),
    algorithmic <strong style="color:#e8e8f0">Communities</strong> (12 from NetworkX — stroke shows cluster for comparison),
    and <strong style="color:#e8e8f0">Bottleneck</strong> heatmap (composite risk score).
    <br><br>
    <span style="color:#555">CUE files are the source of truth. <a href="https://cuelang.org">cuelang.org</a></span>
  </div>
  <nav>
    <button class="active" data-view="graph">Graph</button>
    <button data-view="dashboard">Gap Dashboard</button>
    <button data-view="bridges">Sole Connectors</button>
    <button data-view="cascade">Exposure Cascade</button>
    <button data-view="scatter">Evidence Gaps</button>
    <button data-view="chord">Cluster Map</button>
    <button data-view="structural">Structural</button>
    <a href="compare.html" style="background:#1a1a2a;border:1px solid #2a2a3a;color:#888;padding:4px 12px;text-decoration:none;font-size:11px;border-radius:3px;display:inline-flex;align-items:center;margin-left:auto">How This Compares</a>
  </nav>
  <div class="main graph-mode" id="main">
    <div id="graph-container">
      <div class="graph-controls" id="graph-controls">
        <button class="active" data-color="clusters">Clusters</button>
        <button data-color="communities">Communities</button>
        <button data-color="bottleneck">Bottleneck</button>
      </div>
      <div class="legend" id="legend"></div>
    </div>
    <div id="inspector" class="empty">Click a node to inspect</div>
    <div id="dashboard"></div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
// DATA LOADING
// ═══════════════════════════════════════════════════════════════

const CLUSTER_COLORS = {
  core: '#ff6b6b', financial: '#4ecdc4', hedge_fund: '#45b7d1',
  paypal_mafia: '#96ceb4', crypto: '#ffeaa7', allegations: '#ff7675',
  political: '#74b9ff', cabinet: '#a29bfe', legal: '#fd79a8',
  doj: '#e17055', shell: '#636e72', academia: '#00b894',
  media: '#fdcb6e', banking: '#00cec9', victim: '#d63031',
  intelligence: '#6c5ce7', tech: '#0984e3', staff: '#b2bec3',
  family: '#e84393', unclassified: '#636e72'
};

let graphData, reportData, insightsData, analysisData, entitiesData, flowsData, docsData, networkxData;
let selectedNode = null;
let currentColorMode = 'clusters';
let bottleneckScores = {};
let maxBottleneck = 1;
const COMMUNITY_COLORS = ['#4e79a7','#f28e2b','#e15759','#76b7b2','#59a14f','#edc948','#b07aa1','#ff9da7','#9c755f','#bab0ac','#86bcb6','#8cd17d'];

async function loadData() {
  try {
    const files = ['graph','report','insights','analysis','entities','flows','documents','networkx'];
    const results = await Promise.all(files.map(f =>
      fetch(`data/${f}.json`).then(r => {
        if (!r.ok) throw new Error(`Failed to load ${f}.json: ${r.status}`);
        return r.json();
      })
    ));
    [graphData, reportData, insightsData, analysisData, entitiesData, flowsData, docsData, networkxData] = results;

    // Build node lookup
    graphData._nodeMap = {};
    graphData.nodes.forEach(n => graphData._nodeMap[n.id] = n);

    // Build bottleneck score lookup
    (analysisData.structural?.bottleneck || []).forEach(b => bottleneckScores[b.entity] = b.score);
    maxBottleneck = Math.max(...Object.values(bottleneckScores), 1);

    document.getElementById('loading').remove();
    renderStats();
    renderLegend();
    renderGraph();
    renderDashboard();
  } catch (err) {
    const loading = document.getElementById('loading');
    loading.innerHTML = `<div class="error-banner">
      <strong>Failed to load data</strong><br>
      ${esc(err.message)}<br><br>
      Run <code>./build.sh</code> to generate the data files, then serve with:<br>
      <code>python3 -m http.server -d site 8080</code>
    </div>`;
  }
}

// Minimal HTML escaping for dynamic text
function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

// ═══════════════════════════════════════════════════════════════
// HEADER STATS
// ═══════════════════════════════════════════════════════════════

function renderStats() {
  const s = reportData.summary;
  document.getElementById('stats').innerHTML = `
    <div class="stat"><span class="stat-val">${s.total_entities}</span> entities</div>
    <div class="stat"><span class="stat-val ${s.evidence_coverage_pct < 50 ? 'stat-bad' : ''}">${s.evidence_coverage_pct.toFixed(1)}%</span> evidence</div>
    <div class="stat"><span class="stat-val stat-bad">${s.orphan_entities}</span> orphans</div>
    <div class="stat"><span class="stat-val stat-bad">${s.unidirectional_connections}</span> one-way</div>
    <div class="stat"><span class="stat-val">${analysisData.hop_distance.from_epstein.reachability.total_reachable}</span> reachable from Epstein</div>
  `;
}

// ═══════════════════════════════════════════════════════════════
// LEGEND
// ═══════════════════════════════════════════════════════════════

function renderLegend() {
  const clusters = reportData.coverage.clusters;
  document.getElementById('legend').innerHTML = Object.entries(clusters)
    .sort((a,b) => b[1] - a[1])
    .map(([c, n]) => `<div class="legend-item"><div class="legend-dot" style="background:${CLUSTER_COLORS[c] || '#636e72'}"></div>${c} (${n})</div>`)
    .join('');
}

// ═══════════════════════════════════════════════════════════════
// FORCE GRAPH
// ═══════════════════════════════════════════════════════════════

function renderGraph() {
  const container = document.getElementById('graph-container');
  const width = container.clientWidth;
  const height = container.clientHeight;

  // Deduplicate links: keep one per pair, prefer bidirectional
  const linkMap = new Map();
  graphData.links.forEach(l => {
    const key = [l.source, l.target].sort().join('--');
    const existing = linkMap.get(key);
    if (!existing || l.bidirectional) {
      linkMap.set(key, {...l, bidirectional: l.bidirectional || (existing && existing.bidirectional)});
    }
  });
  const links = Array.from(linkMap.values());

  const svg = d3.select('#graph-container').append('svg')
    .attr('viewBox', [0, 0, width, height]);

  // Zoom
  const g = svg.append('g');
  svg.call(d3.zoom().scaleExtent([0.1, 8]).on('zoom', e => g.attr('transform', e.transform)));

  // Simulation
  const sim = d3.forceSimulation(graphData.nodes)
    .force('link', d3.forceLink(links).id(d => d.id).distance(80))
    .force('charge', d3.forceManyBody().strength(-120))
    .force('center', d3.forceCenter(width/2, height/2))
    .force('collision', d3.forceCollide().radius(d => nodeRadius(d) + 2))
    .force('x', d3.forceX(width/2).strength(0.03))
    .force('y', d3.forceY(height/2).strength(0.03));

  // Links
  const link = g.append('g').selectAll('line')
    .data(links).join('line')
    .attr('class', d => `link ${d.bidirectional ? 'bidirectional' : ''}`)
    .attr('stroke', d => d.bidirectional ? '#3a3a5a' : '#2a2a3a')
    .attr('stroke-width', d => d.bidirectional ? 1.5 : 0.8)
    .attr('stroke-dasharray', d => d.bidirectional ? null : '4,3');

  // Nodes
  const node = g.append('g').selectAll('g')
    .data(graphData.nodes).join('g')
    .attr('class', 'node')
    .call(d3.drag().on('start', dragStart).on('drag', dragging).on('end', dragEnd));

  // Node circles
  node.append('circle')
    .attr('r', d => nodeRadius(d))
    .attr('fill', d => CLUSTER_COLORS[d.cluster] || '#636e72')
    .attr('fill-opacity', d => d.has_evidence ? 0.9 : 0.25)
    .attr('stroke', d => {
      if (d.gap_count >= 3) return '#f85149';
      if (d.gap_count >= 1) return '#f0ad4e';
      return CLUSTER_COLORS[d.cluster] || '#636e72';
    })
    .on('click', (e, d) => selectNode(d))
    .on('mouseover', (e, d) => showTooltip(e, d))
    .on('mouseout', hideTooltip);

  // Labels for larger nodes
  node.filter(d => d.connection_count + d.inbound_count >= 8)
    .append('text')
    .attr('dx', d => nodeRadius(d) + 3)
    .attr('dy', 3)
    .text(d => d.name);

  // Simulation tick
  sim.on('tick', () => {
    link
      .attr('x1', d => d.source.x).attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
    node.attr('transform', d => `translate(${d.x},${d.y})`);
  });

  function nodeRadius(d) {
    return Math.max(3, Math.min(20, Math.sqrt(d.connection_count + d.inbound_count) * 2.5));
  }

  function dragStart(e, d) { if (!e.active) sim.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
  function dragging(e, d) { d.fx = e.x; d.fy = e.y; }
  function dragEnd(e, d) { if (!e.active) sim.alphaTarget(0); d.fx = null; d.fy = null; }

  // Store references for highlighting
  window._graphLink = link;
  window._graphNode = node;

  // Graph color mode controls
  document.querySelectorAll('#graph-controls button').forEach(btn => {
    btn.addEventListener('click', () => recolorNodes(btn.dataset.color));
  });

  // Tooltip element
  const tooltip = d3.select('body').append('div').attr('class', 'tooltip').style('display', 'none');
  function showTooltip(e, d) {
    tooltip.style('display', 'block')
      .style('left', (e.pageX + 12) + 'px').style('top', (e.pageY - 12) + 'px')
      .html(`<strong>${esc(d.name)}</strong> [${esc(d.cluster)}]<br>
        ${d.connection_count} out / ${d.inbound_count} in / ${d.gap_count} gaps
        ${d.mention_count > 0 ? '<br>' + d.mention_count + ' corpus mentions' : ''}`);
  }
  function hideTooltip() { tooltip.style('display', 'none'); }
}

// ═══════════════════════════════════════════════════════════════
// GRAPH COLOR MODES
// ═══════════════════════════════════════════════════════════════

function recolorNodes(mode) {
  currentColorMode = mode;
  document.querySelectorAll('#graph-controls button').forEach(b =>
    b.classList.toggle('active', b.dataset.color === mode));

  window._graphNode.select('circle')
    .transition().duration(400)
    .attr('fill', d => {
      if (mode === 'communities') {
        const comm = networkxData?.nodes?.[d.id]?.community;
        return comm !== undefined ? COMMUNITY_COLORS[comm % COMMUNITY_COLORS.length] : '#333';
      }
      if (mode === 'bottleneck') {
        const score = bottleneckScores[d.id] || 0;
        return score > 0 ? d3.interpolateYlOrRd(0.2 + 0.8 * score / maxBottleneck) : '#1a1a2a';
      }
      return CLUSTER_COLORS[d.cluster] || '#636e72';
    })
    .attr('fill-opacity', d => {
      if (mode === 'bottleneck') return Math.max(0.15, (bottleneckScores[d.id] || 0) / maxBottleneck);
      if (mode === 'communities') return 0.8;
      return d.has_evidence ? 0.9 : 0.25;
    })
    .attr('stroke', d => {
      if (mode === 'communities') return CLUSTER_COLORS[d.cluster] || '#636e72';
      if (d.gap_count >= 3) return '#f85149';
      if (d.gap_count >= 1) return '#f0ad4e';
      return CLUSTER_COLORS[d.cluster] || '#636e72';
    });

  updateLegend(mode);
}

function updateLegend(mode) {
  const legend = document.getElementById('legend');
  if (mode === 'communities') {
    const commCounts = {};
    Object.values(networkxData?.nodes || {}).forEach(n => {
      commCounts[n.community] = (commCounts[n.community] || 0) + 1;
    });
    const disagreements = Object.entries(networkxData?.nodes || {}).filter(([id, n]) => {
      const node = graphData._nodeMap[id];
      if (!node) return false;
      // Find most common cluster in this community
      const commMembers = Object.entries(networkxData.nodes).filter(([, m]) => m.community === n.community);
      const clusterVotes = {};
      commMembers.forEach(([mid]) => { const mn = graphData._nodeMap[mid]; if (mn) clusterVotes[mn.cluster] = (clusterVotes[mn.cluster] || 0) + 1; });
      const topCluster = Object.entries(clusterVotes).sort((a, b) => b[1] - a[1])[0]?.[0];
      return node.cluster !== topCluster;
    }).length;
    legend.innerHTML = Object.entries(commCounts)
      .sort((a, b) => b[1] - a[1])
      .map(([c, n]) => `<div class="legend-item"><div class="legend-dot" style="background:${COMMUNITY_COLORS[c % COMMUNITY_COLORS.length]}"></div>C${c} (${n})</div>`)
      .join('') +
      `<div class="legend-item" style="margin-left:8px;color:#f0ad4e">${disagreements} cluster/community mismatches</div>`;
  } else if (mode === 'bottleneck') {
    legend.innerHTML =
      '<div class="legend-item"><div class="legend-dot" style="background:#1a1a2a;border:1px solid #333"></div>0</div>' +
      '<div class="legend-item"><div class="legend-dot" style="background:' + d3.interpolateYlOrRd(0.35) + '"></div>low</div>' +
      '<div class="legend-item"><div class="legend-dot" style="background:' + d3.interpolateYlOrRd(0.6) + '"></div>med</div>' +
      '<div class="legend-item"><div class="legend-dot" style="background:' + d3.interpolateYlOrRd(1.0) + '"></div>high (' + maxBottleneck + ')</div>';
  } else {
    renderLegend();
  }
}

// ═══════════════════════════════════════════════════════════════
// NODE SELECTION & INSPECTOR
// ═══════════════════════════════════════════════════════════════

function selectNode(d) {
  selectedNode = d;

  // Highlight in graph
  window._graphNode.classed('selected', n => n.id === d.id);
  window._graphLink.classed('highlighted', l =>
    (l.source.id || l.source) === d.id || (l.target.id || l.target) === d.id);

  const entity = entitiesData[d.id];
  const panel = document.getElementById('inspector');
  panel.classList.remove('empty');

  // Build connections list
  const connections = Object.keys(entity.connections || {});
  const inbound = [];
  graphData.links.forEach(l => {
    const src = l.source.id || l.source;
    const tgt = l.target.id || l.target;
    if (tgt === d.id && !connections.includes(src)) inbound.push(src);
  });

  // Get flows for this entity
  const entityFlows = insightsData.flows_by_entity[d.id] || {};
  const entityDocs = insightsData.docs_mentioning[d.id] || {};

  // Get hop distance
  const hop = analysisData.hop_distance.from_epstein;
  let hopDist = 'unknown';
  if (hop.wave_0.includes(d.id)) hopDist = '0 (self)';
  else if (hop.wave_1.includes(d.id)) hopDist = '1';
  else if (hop.wave_2.includes(d.id)) hopDist = '2';
  else if (hop.wave_3.includes(d.id)) hopDist = '3';
  else if (hop.wave_4.includes(d.id)) hopDist = '4';

  // Check sole connector status
  const soleConn = analysisData.sole_connectors.by_entity.find(e => e.entity === d.id);
  const networkxNode = networkxData?.nodes?.[d.id];

  panel.innerHTML = `
    <div class="entity-name">${esc(d.name)}</div>
    <div class="entity-id">${esc(d.id)}</div>

    <div class="inspector-section">
      <h3>Known</h3>
      <div class="field"><span class="field-label">Cluster</span><span class="field-value"><span class="badge badge-cluster cluster-${esc(d.cluster)}">${esc(d.cluster)}</span></span></div>
      <div class="field"><span class="field-label">Types</span><span class="field-value">${d.types.map(t => `<span class="badge badge-type">${esc(t)}</span>`).join('')}</span></div>
      ${d.role ? `<div class="field"><span class="field-label">Role</span><span class="field-value">${esc(d.role)}</span></div>` : ''}
      ${d.notes ? `<div class="field"><span class="field-label">Notes</span><span class="field-value">${esc(d.notes)}</span></div>` : ''}
      <div class="field"><span class="field-label">Corpus mentions</span><span class="field-value">${d.mention_count || 0}</span></div>
      <div class="field"><span class="field-label">Hops from Epstein</span><span class="field-value">${hopDist}</span></div>
      <div class="field"><span class="field-label">Reciprocity</span><span class="field-value">${Math.round(d.reciprocity_pct)}%</span></div>
      <div class="field"><span class="field-label">Bridges</span><span class="field-value">${d.bridge_count > 0 ? d.bridge_clusters.map(c => `<span class="badge badge-bridge">${c}</span>`).join('') : 'none'}</span></div>
      ${soleConn ? `<div class="field"><span class="field-label">Sole bridge</span><span class="field-value">${soleConn.sole_bridge_pairs.map(p => `<span class="badge badge-bridge">${p}</span>`).join('')}</span></div>` : ''}
      <div class="field"><span class="field-label">Clustering</span><span class="field-value" style="color:${d.clustering_coeff === 0 ? '#f0ad4e' : '#c8c8d0'}">${Math.round(d.clustering_coeff)}%${d.clustering_coeff === 0 && (d.connection_count + d.inbound_count) >= 2 ? ' (structural hole)' : ''}</span></div>
      <div class="field"><span class="field-label">Power asymmetry</span><span class="field-value" style="color:${d.power_asymmetry > 20 ? '#4caf50' : d.power_asymmetry < -50 ? '#f85149' : '#c8c8d0'}">${d.power_asymmetry > 0 ? '+' : ''}${Math.round(d.power_asymmetry)} ${d.power_asymmetry > 20 ? '(authority)' : d.power_asymmetry < -50 ? '(claimer)' : ''}</span></div>
      <div class="field"><span class="field-label">Cluster affinity</span><span class="field-value" style="color:${d.cluster_affinity < 30 ? '#f0ad4e' : '#c8c8d0'}">${Math.round(d.cluster_affinity)}% in-cluster</span></div>

      <div class="field" style="margin-top:8px"><span class="field-label">Connections</span><span class="field-value">${d.connection_count} out / ${d.inbound_count} in</span></div>
      <ul class="conn-list">
        ${connections.filter(c => graphData._nodeMap[c]).map(c => {
          const target = graphData._nodeMap[c];
          const bidir = target && Object.keys(entitiesData[c]?.connections || {}).includes(d.id);
          return `<li class="${bidir ? 'bidir' : 'unidir-out'}" onclick="selectNode(graphData._nodeMap['${c}'])">${entitiesData[c]?.name || c} <span class="badge badge-cluster cluster-${target?.cluster}">${target?.cluster}</span></li>`;
        }).join('')}
        ${inbound.filter(c => graphData._nodeMap[c]).map(c => {
          const src = graphData._nodeMap[c];
          return `<li class="unidir-in" onclick="selectNode(graphData._nodeMap['${c}'])">${entitiesData[c]?.name || c} <span class="badge badge-cluster cluster-${src?.cluster}">${src?.cluster}</span></li>`;
        }).join('')}
      </ul>

      ${Object.keys(entityFlows).length ? `
        <div class="field" style="margin-top:8px"><span class="field-label">Flows</span></div>
        ${Object.entries(entityFlows).map(([fname, f]) =>
          `<div class="field"><span class="field-label" style="min-width:20px">${f.role === 'source' ? '→' : '←'}</span><span class="field-value">${f.amount} ${f.role === 'source' ? 'to' : 'from'} ${f.other} (${f.flow_type})</span></div>`
        ).join('')}
      ` : ''}

      ${Object.keys(entityDocs).length ? `
        <div class="field" style="margin-top:8px"><span class="field-label">Documents</span></div>
        ${Object.keys(entityDocs).map(doc =>
          `<div class="field"><span class="field-label" style="min-width:20px"></span><span class="field-value">${doc}</span></div>`
        ).join('')}
      ` : ''}

      ${Object.keys(entity.evidence || {}).length ? `
        <div class="field" style="margin-top:8px"><span class="field-label">Evidence</span></div>
        ${Object.keys(entity.evidence).map(e =>
          `<div class="field"><span class="field-label" style="min-width:20px"></span><span class="field-value">${e}</span></div>`
        ).join('')}
      ` : ''}
    </div>

    ${d.gap_count > 0 ? `
    <div class="inspector-section missing">
      <h3>Missing (${d.gap_count} gaps)</h3>
      ${d.gap_categories.map(g => `<div class="field"><span class="gap-pill gap-${g}">${g.replace(/_/g, ' ')}</span></div>`).join('')}
      ${d.is_orphan ? '<div class="field"><span class="field-value" style="color:#f0ad4e">No entity connects TO this node</span></div>' : ''}
      ${d.unidirectional_out > 0 ? `<div class="field"><span class="field-value" style="color:#f0ad4e">${d.unidirectional_out} connections not reciprocated</span></div>` : ''}
    </div>
    ` : ''}

    <div class="inspector-section">
      <h3>Network Metrics</h3>
      ${networkxNode ? `
        <div class="field"><span class="field-label">Betweenness</span><span class="field-value">${(networkxNode.betweenness * 100).toFixed(1)}%</span></div>
        <div class="field"><span class="field-label">PageRank</span><span class="field-value">${(networkxNode.pagerank * 100).toFixed(1)}%</span></div>
        <div class="field"><span class="field-label">Eigenvector</span><span class="field-value">${(networkxNode.eigenvector * 100).toFixed(1)}%</span></div>
        <div class="field"><span class="field-label">K-core</span><span class="field-value">${networkxNode.coreness}</span></div>
        <div class="field"><span class="field-label">Community</span><span class="field-value">Community ${networkxNode.community}</span></div>
      ` : '<div class="field"><span class="field-value" style="color:#666">No network data</span></div>'}
    </div>


    <div class="inspector-section leads">
      <h3>Leads</h3>
      ${d.mention_count > 0 && !d.has_evidence ? `<div class="field"><span class="field-value"><a href="https://analytics.dugganusa.com/api/v1/search?q=${encodeURIComponent(d.name)}&indexes=epstein_files" target="_blank">Search API: ${d.mention_count} hits available</a></span></div>` : ''}
      ${d.mention_count === 0 ? '<div class="field"><span class="field-value" style="color:#666">Zero corpus presence — may not appear in DOJ documents</span></div>' : ''}
      ${!d.has_evidence ? '<div class="field"><span class="field-value" style="color:#f85149">Needs evidence: find document IDs from DOJ releases, court filings, or depositions</span></div>' : ''}
    </div>
  `;
}

// ═══════════════════════════════════════════════════════════════
// GAP DASHBOARD
// ═══════════════════════════════════════════════════════════════

function renderDashboard() {
  // Flatten all nodes with gap info into a sortable table
  const rows = graphData.nodes.map(n => ({
    ...n,
    total_degree: n.connection_count + n.inbound_count,
  })).sort((a, b) => b.gap_count - a.gap_count || b.mention_count - a.mention_count);

  const dashboard = document.getElementById('dashboard');
  dashboard.innerHTML = `
    <div class="dash-header">
      <button class="dash-filter active" data-filter="all">All <span class="count">${rows.length}</span></button>
      <button class="dash-filter" data-filter="missing_evidence">No evidence <span class="count">${rows.filter(r => r.gap_categories.includes('missing_evidence')).length}</span></button>
      <button class="dash-filter" data-filter="orphan">Orphans <span class="count">${rows.filter(r => r.gap_categories.includes('orphan')).length}</span></button>
      <button class="dash-filter" data-filter="cluster_isolated">Cluster isolated <span class="count">${rows.filter(r => r.gap_categories.includes('cluster_isolated')).length}</span></button>
      <button class="dash-filter" data-filter="type_inconsistent">Type mismatch <span class="count">${rows.filter(r => r.gap_categories.includes('type_inconsistent')).length}</span></button>
      <button class="dash-filter" data-filter="has_evidence">Has evidence <span class="count">${rows.filter(r => r.has_evidence).length}</span></button>
    </div>
    <table>
      <thead><tr>
        <th data-sort="name">Name</th>
        <th data-sort="cluster">Cluster</th>
        <th data-sort="mention_count">Mentions</th>
        <th data-sort="total_degree">Degree</th>
        <th data-sort="gap_count">Gaps</th>
        <th data-sort="bridge_count">Bridges</th>
        <th data-sort="reciprocity_pct">Recip%</th>
        <th>Gap Types</th>
      </tr></thead>
      <tbody id="dash-body"></tbody>
    </table>
  `;

  let currentFilter = 'all';
  let sortKey = 'gap_count';
  let sortDir = -1;

  function renderRows() {
    let filtered = rows;
    if (currentFilter === 'has_evidence') filtered = rows.filter(r => r.has_evidence);
    else if (currentFilter !== 'all') filtered = rows.filter(r => r.gap_categories.includes(currentFilter));
    filtered.sort((a, b) => (a[sortKey] > b[sortKey] ? 1 : -1) * sortDir);

    document.getElementById('dash-body').innerHTML = filtered.map(r => `
      <tr class="clickable" onclick="switchToGraphAndSelect('${esc(r.id)}')">
        <td><strong>${esc(r.name)}</strong></td>
        <td><span class="badge badge-cluster cluster-${esc(r.cluster)}">${esc(r.cluster)}</span></td>
        <td>${r.mention_count}</td>
        <td>${r.total_degree}</td>
        <td>${r.gap_count}</td>
        <td>${r.bridge_count}</td>
        <td>${Math.round(r.reciprocity_pct)}%</td>
        <td>${r.gap_categories.map(g => `<span class="gap-pill gap-${g}">${g.replace(/_/g,' ')}</span>`).join('')}</td>
      </tr>
    `).join('');
  }

  // Filter buttons
  dashboard.querySelectorAll('.dash-filter').forEach(btn => {
    btn.addEventListener('click', () => {
      dashboard.querySelectorAll('.dash-filter').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentFilter = btn.dataset.filter;
      renderRows();
    });
  });

  // Sort headers
  dashboard.querySelectorAll('th[data-sort]').forEach(th => {
    th.addEventListener('click', () => {
      if (sortKey === th.dataset.sort) sortDir *= -1;
      else { sortKey = th.dataset.sort; sortDir = -1; }
      renderRows();
    });
  });

  renderRows();
}

function switchToGraphAndSelect(id) {
  switchView('graph');
  const node = graphData._nodeMap[id];
  if (node) selectNode(node);
}

// ═══════════════════════════════════════════════════════════════
// BRIDGES VIEW
// ═══════════════════════════════════════════════════════════════

function renderBridges() {
  const dashboard = document.getElementById('dashboard');
  const sc = analysisData.sole_connectors;
  const byEntity = sc.by_entity.sort((a, b) => b.pair_count - a.pair_count);

  dashboard.innerHTML = `
    <h2 style="margin-bottom:12px;color:#f0ad4e">Sole Connectors — ${sc.count} cluster pairs depend on a single entity</h2>
    <p style="margin-bottom:16px;color:#888">These entities are the ONLY bridge between two cluster worlds. Removing them disconnects those communities.</p>
    <table>
      <thead><tr><th>Entity</th><th>Cluster</th><th>Bridge Pairs</th><th>#</th></tr></thead>
      <tbody>
        ${byEntity.map(e => `
          <tr class="clickable" onclick="switchToGraphAndSelect('${esc(e.entity)}')">
            <td><strong>${esc(e.name)}</strong></td>
            <td><span class="badge badge-cluster cluster-${esc(e.cluster)}">${esc(e.cluster)}</span></td>
            <td>${e.sole_bridge_pairs.map(p => `<span class="badge badge-bridge">${p.replace('|', ' → ')}</span>`).join(' ')}</td>
            <td>${e.pair_count}</td>
          </tr>
        `).join('')}
      </tbody>
    </table>
  `;
}

// ═══════════════════════════════════════════════════════════════
// CASCADE VIEW
// ═══════════════════════════════════════════════════════════════

function renderCascade() {
  const dashboard = document.getElementById('dashboard');
  const ec = analysisData.exposure_cascades;

  dashboard.innerHTML = `
    <h2 style="margin-bottom:12px;color:#f85149">Exposure Cascades — If someone cooperates, who's at risk?</h2>
    <p style="margin-bottom:16px;color:#888">Wave 1 = directly named in testimony. Wave 2 = second-degree exposure through wave 1 connections.</p>
    ${Object.entries(ec).map(([key, c]) => `
      <div style="margin-bottom:24px;padding:12px;background:#12121a;border:1px solid #2a2a3a;border-radius:4px">
        <h3 style="color:#e8e8f0;margin-bottom:8px">${entitiesData[c.target]?.name || c.target} cooperates</h3>
        <div class="field"><span class="field-label">Total exposed</span><span class="field-value" style="color:#f85149;font-weight:600">${c.total_exposed} entities</span></div>
        <div class="field"><span class="field-label">Wave 1 (direct)</span><span class="field-value">${c.wave_1.length}: ${c.wave_1.sort().map(e => `<span class="badge badge-cluster cluster-${graphData._nodeMap[e]?.cluster}" style="cursor:pointer" onclick="switchToGraphAndSelect('${e}')">${entitiesData[e]?.name || e}</span>`).join(' ')}</span></div>
        <div class="field"><span class="field-label">Wave 2 (2nd deg)</span><span class="field-value">${c.wave_2.length}: ${c.wave_2.sort().map(e => `<span class="badge badge-cluster cluster-${graphData._nodeMap[e]?.cluster}" style="cursor:pointer" onclick="switchToGraphAndSelect('${e}')">${entitiesData[e]?.name || e}</span>`).join(' ')}</span></div>
      </div>
    `).join('')}
  `;
}

// ═══════════════════════════════════════════════════════════════
// EVIDENCE GAP SCATTER — "Your API found them, nobody documented them"
// X = corpus mentions (from DugganUSA API), Y = evidence count
// The 117 dots at y=0 ARE the story.
// ═══════════════════════════════════════════════════════════════

function renderGapScatter() {
  const dashboard = document.getElementById('dashboard');
  const noEvidence = graphData.nodes.filter(n => !n.has_evidence).length;
  const withEvidence = graphData.nodes.filter(n => n.has_evidence).length;

  dashboard.innerHTML = `
    <h2 style="margin-bottom:4px;color:#f85149">Evidence Gaps — Corpus Presence vs. Documentation</h2>
    <p style="margin-bottom:4px;color:#888">X = mentions in 71k-doc DugganUSA corpus. Y = linked evidence citations. Dot size = connection degree. Opacity = evidence status.</p>
    <p style="margin-bottom:12px;color:#666;font-size:11px">
      <span style="color:#f85149;font-weight:600">${noEvidence} entities</span> below the line (undocumented) vs.
      <span style="color:#4caf50;font-weight:600">${withEvidence}</span> above (documented).
      High-mention entities below the line are the best candidates for evidence linking — the corpus already found them.
    </p>
    <div id="scatter-container" style="width:100%;height:calc(100vh - 180px);position:relative"></div>
  `;

  const container = document.getElementById('scatter-container');
  requestAnimationFrame(() => _renderScatter(container));
}

function _renderScatter(container) {
  const width = Math.max(300, container.clientWidth);
  const height = Math.max(200, container.clientHeight);
  const margin = {top: 30, right: 30, bottom: 50, left: 60};
  const innerW = width - margin.left - margin.right;
  const innerH = height - margin.top - margin.bottom;

  // Prepare data — jitter y=0 entities slightly for visibility
  const rng = d3.randomNormal(0, 0.15);
  const dots = graphData.nodes.map(n => ({
    ...n,
    total_degree: n.connection_count + n.inbound_count,
    jitteredEvidence: n.evidence_count > 0 ? n.evidence_count : Math.min(0, rng()),
  }));

  const maxMentions = d3.max(dots, d => d.mention_count) || 1;
  const maxEvidence = d3.max(dots, d => d.evidence_count) || 1;

  // Scales
  const x = d3.scaleSymlog()
    .domain([0, maxMentions])
    .range([0, innerW]);

  const y = d3.scaleLinear()
    .domain([-0.8, Math.max(maxEvidence, 1) + 0.8])
    .range([innerH, 0]);

  const r = d3.scaleSqrt()
    .domain([0, d3.max(dots, d => d.total_degree)])
    .range([3, 18]);

  const svg = d3.select('#scatter-container').append('svg')
    .attr('width', width).attr('height', height);

  const g = svg.append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);

  // Danger zone background (below evidence line)
  g.append('rect')
    .attr('x', 0).attr('y', y(0.4))
    .attr('width', innerW).attr('height', innerH - y(0.4))
    .attr('fill', '#1a0a0a').attr('opacity', 0.4);

  // Safe zone label
  g.append('text')
    .attr('x', innerW - 8).attr('y', y(maxEvidence) + 14)
    .attr('text-anchor', 'end')
    .attr('fill', '#4caf50').attr('font-size', '10px').attr('opacity', 0.7)
    .text('DOCUMENTED');

  // Danger zone label
  g.append('text')
    .attr('x', innerW - 8).attr('y', y(-0.6))
    .attr('text-anchor', 'end')
    .attr('fill', '#f85149').attr('font-size', '10px').attr('opacity', 0.7)
    .text('UNDOCUMENTED');

  // Threshold line
  g.append('line')
    .attr('x1', 0).attr('x2', innerW)
    .attr('y1', y(0.4)).attr('y2', y(0.4))
    .attr('stroke', '#f85149').attr('stroke-dasharray', '6,4').attr('opacity', 0.5);

  // Axes
  const xAxis = d3.axisBottom(x)
    .tickValues([0, 10, 100, 1000, 5000].filter(v => v <= maxMentions))
    .tickFormat(d => d >= 1000 ? (d/1000)+'k' : d);
  g.append('g')
    .attr('transform', `translate(0,${innerH})`)
    .call(xAxis)
    .selectAll('text,line,path').attr('stroke', '#444').attr('fill', '#666');

  const yAxis = d3.axisLeft(y).tickValues([0, 1, 2, 3, 4, 5].filter(v => v <= maxEvidence));
  g.append('g')
    .call(yAxis)
    .selectAll('text,line,path').attr('stroke', '#444').attr('fill', '#666');

  // Axis labels
  g.append('text')
    .attr('x', innerW / 2).attr('y', innerH + 40)
    .attr('text-anchor', 'middle').attr('fill', '#888').attr('font-size', '11px')
    .text('Corpus mentions (DugganUSA API) →');

  g.append('text')
    .attr('transform', 'rotate(-90)')
    .attr('x', -innerH / 2).attr('y', -45)
    .attr('text-anchor', 'middle').attr('fill', '#888').attr('font-size', '11px')
    .text('↑ Evidence citations');

  // Tooltip
  const tip = d3.select('#scatter-container').append('div')
    .attr('class', 'tooltip').style('display', 'none');

  // Dots
  g.selectAll('circle.dot')
    .data(dots.sort((a, b) => b.total_degree - a.total_degree))
    .join('circle')
    .attr('class', 'dot')
    .attr('cx', d => x(d.mention_count))
    .attr('cy', d => y(d.jitteredEvidence))
    .attr('r', d => r(d.total_degree))
    .attr('fill', d => CLUSTER_COLORS[d.cluster] || '#636e72')
    .attr('fill-opacity', d => d.has_evidence ? 0.85 : 0.3)
    .attr('stroke', d => d.has_evidence ? '#4caf50' : (d.gap_count >= 3 ? '#f85149' : '#555'))
    .attr('stroke-width', d => d.has_evidence ? 2 : 1)
    .attr('cursor', 'pointer')
    .on('click', (e, d) => switchToGraphAndSelect(d.id))
    .on('mouseover', (e, d) => {
      tip.style('display', 'block')
        .style('left', (e.offsetX + 14) + 'px').style('top', (e.offsetY - 14) + 'px')
        .html(`<strong>${esc(d.name)}</strong> [${d.cluster}]<br>
          ${d.mention_count} corpus mentions<br>
          ${d.evidence_count} evidence citations<br>
          ${d.total_degree} connections / ${d.gap_count} gaps`);
    })
    .on('mouseout', () => tip.style('display', 'none'));

  // Label high-mention zero-evidence entities (the story)
  const labelDots = dots
    .filter(d => (d.mention_count >= 500 && !d.has_evidence) || d.has_evidence)
    .sort((a, b) => b.mention_count - a.mention_count)
    .slice(0, 20);

  g.selectAll('text.label')
    .data(labelDots)
    .join('text')
    .attr('class', 'label')
    .attr('x', d => x(d.mention_count) + r(d.total_degree) + 4)
    .attr('y', d => y(d.jitteredEvidence) + 3)
    .attr('fill', d => d.has_evidence ? '#4caf50' : '#f85149')
    .attr('font-size', '9px')
    .attr('opacity', 0.8)
    .text(d => d.name);
}

// ═══════════════════════════════════════════════════════════════
// CLUSTER CHORD DIAGRAM — inter-cluster connectivity + SPOFs
// Thick chords = many connections. Thin/dashed = sole connector.
// Infra analogy: network segmentation map with single points of failure.
// ═══════════════════════════════════════════════════════════════

function renderChordDiagram() {
  const dashboard = document.getElementById('dashboard');
  const sc = analysisData.sole_connectors;

  dashboard.innerHTML = `
    <h2 style="margin-bottom:4px;color:#6ea8fe">Cluster Connectivity Map</h2>
    <p style="margin-bottom:4px;color:#888">Chord thickness = number of cross-cluster connections. <span style="color:#f0ad4e">Orange dashed</span> = sole connector (SPOF — only one entity bridges these clusters).</p>
    <p style="margin-bottom:12px;color:#666;font-size:11px">${sc.count} cluster pairs depend on a single bridge entity. Hover for details.</p>
    <div id="chord-container" style="width:100%;height:calc(100vh - 180px);display:flex;align-items:center;justify-content:center;position:relative"></div>
  `;

  const container = document.getElementById('chord-container');
  // Defer to next frame so container has layout dimensions
  requestAnimationFrame(() => _renderChord(container));
}

function _renderChord(container) {
  const sc = analysisData.sole_connectors;
  const size = Math.max(200, Math.min(container.clientWidth, container.clientHeight) - 40);
  const outerRadius = size / 2;
  const innerRadius = outerRadius - 24;

  // Build cluster list (only clusters with entities)
  const clusterCounts = {};
  graphData.nodes.forEach(n => {
    clusterCounts[n.cluster] = (clusterCounts[n.cluster] || 0) + 1;
  });
  const clusters = Object.keys(clusterCounts).sort((a, b) => clusterCounts[b] - clusterCounts[a]);
  const n = clusters.length;
  const clusterIndex = {};
  clusters.forEach((c, i) => clusterIndex[c] = i);

  // Build weighted matrix from links
  const matrix = Array.from({length: n}, () => new Array(n).fill(0));
  graphData.links.forEach(l => {
    const src = l.source.id || l.source;
    const tgt = l.target.id || l.target;
    const srcCluster = graphData._nodeMap[src]?.cluster;
    const tgtCluster = graphData._nodeMap[tgt]?.cluster;
    if (srcCluster && tgtCluster && srcCluster !== tgtCluster) {
      const i = clusterIndex[srcCluster];
      const j = clusterIndex[tgtCluster];
      if (i !== undefined && j !== undefined) {
        matrix[i][j] += 1;
      }
    }
  });

  // Build sole-connector pair lookup
  const solePairs = new Set();
  if (sc && sc.pairs) {
    sc.pairs.forEach(p => {
      const parts = p.pair.split('|');
      if (parts.length === 2) {
        const key = [clusterIndex[parts[0]], clusterIndex[parts[1]]].sort().join('-');
        solePairs.add(key);
      }
    });
  }
  // Also build from by_entity data
  if (sc && sc.by_entity) {
    sc.by_entity.forEach(e => {
      e.sole_bridge_pairs.forEach(pair => {
        const parts = pair.split('|');
        if (parts.length === 2) {
          const i = clusterIndex[parts[0]];
          const j = clusterIndex[parts[1]];
          if (i !== undefined && j !== undefined) {
            solePairs.add([i, j].sort().join('-'));
          }
        }
      });
    });
  }

  // D3 chord layout
  const chord = d3.chord()
    .padAngle(0.04)
    .sortSubgroups(d3.descending);

  const chords = chord(matrix);
  const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
  const ribbon = d3.ribbon().radius(innerRadius);

  const svg = d3.select('#chord-container').append('svg')
    .attr('width', size + 80).attr('height', size + 80)
    .append('g')
    .attr('transform', `translate(${(size + 80) / 2},${(size + 80) / 2})`);

  // Tooltip
  const tip = d3.select('#chord-container').append('div')
    .attr('class', 'tooltip').style('display', 'none');

  // Arcs (cluster segments)
  svg.selectAll('path.arc')
    .data(chords.groups)
    .join('path')
    .attr('class', 'arc')
    .attr('d', arc)
    .attr('fill', d => CLUSTER_COLORS[clusters[d.index]] || '#636e72')
    .attr('stroke', '#0a0a0f')
    .attr('stroke-width', 1)
    .attr('opacity', 0.85)
    .on('mouseover', (e, d) => {
      tip.style('display', 'block')
        .style('left', (e.offsetX + 14) + 'px').style('top', (e.offsetY - 14) + 'px')
        .html(`<strong>${clusters[d.index]}</strong><br>${clusterCounts[clusters[d.index]]} entities`);
    })
    .on('mouseout', () => tip.style('display', 'none'));

  // Arc labels
  svg.selectAll('text.cluster-label')
    .data(chords.groups)
    .join('text')
    .attr('class', 'cluster-label')
    .each(function(d) {
      const angle = (d.startAngle + d.endAngle) / 2;
      const flip = angle > Math.PI;
      d3.select(this)
        .attr('transform', `rotate(${angle * 180 / Math.PI - 90}) translate(${outerRadius + 8}) ${flip ? 'rotate(180)' : ''}`)
        .attr('text-anchor', flip ? 'end' : 'start')
        .attr('fill', CLUSTER_COLORS[clusters[d.index]] || '#636e72')
        .attr('font-size', '10px')
        .text(clusters[d.index]);
    });

  // Ribbons (chords between clusters)
  svg.selectAll('path.ribbon')
    .data(chords)
    .join('path')
    .attr('class', 'ribbon')
    .attr('d', ribbon)
    .attr('fill', d => {
      const key = [d.source.index, d.target.index].sort().join('-');
      return solePairs.has(key) ? '#f0ad4e' : CLUSTER_COLORS[clusters[d.source.index]] || '#636e72';
    })
    .attr('opacity', d => {
      const key = [d.source.index, d.target.index].sort().join('-');
      return solePairs.has(key) ? 0.6 : 0.25;
    })
    .attr('stroke', d => {
      const key = [d.source.index, d.target.index].sort().join('-');
      return solePairs.has(key) ? '#f0ad4e' : 'none';
    })
    .attr('stroke-dasharray', d => {
      const key = [d.source.index, d.target.index].sort().join('-');
      return solePairs.has(key) ? '4,3' : null;
    })
    .attr('stroke-width', d => {
      const key = [d.source.index, d.target.index].sort().join('-');
      return solePairs.has(key) ? 1.5 : 0;
    })
    .on('mouseover', (e, d) => {
      const key = [d.source.index, d.target.index].sort().join('-');
      const isSole = solePairs.has(key);
      const count = matrix[d.source.index][d.target.index] + matrix[d.target.index][d.source.index];
      let bridgeEntity = '';
      if (isSole && sc && sc.by_entity) {
        const pairStr1 = clusters[d.source.index] + '|' + clusters[d.target.index];
        const pairStr2 = clusters[d.target.index] + '|' + clusters[d.source.index];
        const bridge = sc.by_entity.find(e =>
          e.sole_bridge_pairs.includes(pairStr1) || e.sole_bridge_pairs.includes(pairStr2)
        );
        if (bridge) bridgeEntity = `<br>SPOF: <strong>${esc(bridge.name)}</strong>`;
      }
      tip.style('display', 'block')
        .style('left', (e.offsetX + 14) + 'px').style('top', (e.offsetY - 14) + 'px')
        .html(`<strong>${clusters[d.source.index]}</strong> ↔ <strong>${clusters[d.target.index]}</strong><br>
          ${count} connections${isSole ? '<br><span style="color:#f0ad4e">⚠ Sole connector — single point of failure</span>' : ''}${bridgeEntity}`);
    })
    .on('mouseout', () => tip.style('display', 'none'));
}

// ═══════════════════════════════════════════════════════════════
// STRUCTURAL ANALYSIS — pure topology derivations
// Clustering coefficient, power asymmetry, cluster density,
// bridge redundancy, cascading orphans, cluster affinity.
// ═══════════════════════════════════════════════════════════════

function renderStructural() {
  const dashboard = document.getElementById('dashboard');
  const st = analysisData.structural;
  const nodes = graphData.nodes;

  // Pre-sort data for each section
  const byCC = [...nodes].filter(n => (n.connection_count + n.inbound_count) >= 2)
    .sort((a, b) => a.clustering_coeff - b.clustering_coeff);
  const byPA = [...nodes].filter(n => (n.connection_count + n.inbound_count) >= 2)
    .sort((a, b) => b.power_asymmetry - a.power_asymmetry);
  const orphans = [...st.cascading_orphans].sort((a, b) => b.orphan_count - a.orphan_count);
  const densities = Object.entries(st.cluster_density)
    .sort((a, b) => b[1].density_pct - a[1].density_pct);
  const pairs = Object.entries(st.cluster_pair_bridges);
  const spofCount = pairs.filter(([, v]) => v.is_spof).length;
  const fragileCount = pairs.filter(([, v]) => v.is_fragile).length;
  const healthyCount = pairs.filter(([, v]) => !v.is_spof && !v.is_fragile).length;

  dashboard.innerHTML = `
    <h2 style="margin-bottom:4px;color:#6ea8fe">Structural Analysis — Pure Topology</h2>
    <p style="margin-bottom:12px;color:#888">All metrics derived from graph structure alone. No external data, no inference — just set operations over the adjacency matrix at CUE compile time.</p>

    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:8px;margin-bottom:16px">
      <div style="background:#12121a;border:1px solid #2a2a3a;padding:10px;border-radius:4px">
        <div style="color:#888;font-size:10px">STRUCTURAL HOLES</div>
        <div style="color:#f0ad4e;font-size:20px;font-weight:600">${nodes.filter(n => n.clustering_coeff === 0 && (n.connection_count + n.inbound_count) >= 2).length}</div>
        <div style="color:#666;font-size:10px">clustering coeff = 0%, degree 2+</div>
      </div>
      <div style="background:#12121a;border:1px solid #2a2a3a;padding:10px;border-radius:4px">
        <div style="color:#888;font-size:10px">BRIDGE REDUNDANCY</div>
        <div style="color:#f85149;font-size:20px;font-weight:600">${spofCount} / ${fragileCount} / ${healthyCount}</div>
        <div style="color:#666;font-size:10px">SPOF / fragile / healthy pairs</div>
      </div>
      <div style="background:#12121a;border:1px solid #2a2a3a;padding:10px;border-radius:4px">
        <div style="color:#888;font-size:10px">CASCADE RISK</div>
        <div style="color:#f85149;font-size:20px;font-weight:600">${orphans.length > 0 ? orphans[0].orphan_count : 0}</div>
        <div style="color:#666;font-size:10px">max orphans if one entity removed</div>
      </div>
      <div style="background:#12121a;border:1px solid #2a2a3a;padding:10px;border-radius:4px">
        <div style="color:#888;font-size:10px">LOW AFFINITY</div>
        <div style="color:#f0ad4e;font-size:20px;font-weight:600">${st.low_affinity.length}</div>
        <div style="color:#666;font-size:10px">entities &lt;30% in declared cluster</div>
      </div>
      <div style="background:#12121a;border:1px solid #2a2a3a;padding:10px;border-radius:4px">
        <div style="color:#888;font-size:10px">EVIDENCE FRAGILITY</div>
        <div style="color:#f0ad4e;font-size:20px;font-weight:600">${nodes.filter(n => n.evidence_fragility).length}</div>
        <div style="color:#666;font-size:10px">entities with exactly 1 evidence doc</div>
      </div>
    </div>

    <div id="structural-tabs" style="display:flex;gap:4px;margin-bottom:12px;flex-wrap:wrap">
      <button class="dash-filter active" data-stab="holes">Structural Holes</button>
      <button class="dash-filter" data-stab="power">Power Asymmetry</button>
      <button class="dash-filter" data-stab="density">Cluster Density</button>
      <button class="dash-filter" data-stab="redundancy">Bridge Redundancy</button>
      <button class="dash-filter" data-stab="orphans">Cascading Orphans</button>
      <button class="dash-filter" data-stab="affinity">Cluster Affinity</button>
      <button class="dash-filter" data-stab="bottleneck">Bottleneck</button>
    </div>
    <div id="structural-content"></div>
  `;

  const content = document.getElementById('structural-content');

  function showTab(tab) {
    dashboard.querySelectorAll('#structural-tabs .dash-filter').forEach(b => b.classList.toggle('active', b.dataset.stab === tab));

    if (tab === 'holes') {
      content.innerHTML = `
        <p style="color:#888;margin-bottom:8px;font-size:11px">Clustering coefficient = % of your neighbor pairs that are also connected to each other. CC=0% means you sit in a <strong style="color:#f0ad4e">structural hole</strong> — your neighbors don't know each other. You're the information broker.</p>
        <table><thead><tr>
          <th>Entity</th><th>Cluster</th><th>CC%</th><th>Degree</th><th>Bridges</th><th>Gaps</th>
        </tr></thead><tbody>
          ${byCC.map(n => `
            <tr class="clickable" onclick="switchToGraphAndSelect('${esc(n.id)}')">
              <td><strong>${esc(n.name)}</strong></td>
              <td><span class="badge badge-cluster cluster-${esc(n.cluster)}">${esc(n.cluster)}</span></td>
              <td style="color:${n.clustering_coeff === 0 ? '#f0ad4e' : n.clustering_coeff < 30 ? '#c8c8d0' : '#4caf50'}">${Math.round(n.clustering_coeff)}%</td>
              <td>${n.connection_count + n.inbound_count}</td>
              <td>${n.bridge_count}</td>
              <td>${n.gap_count}</td>
            </tr>
          `).join('')}
        </tbody></table>
      `;
    } else if (tab === 'power') {
      content.innerHTML = `
        <p style="color:#888;margin-bottom:8px;font-size:11px"><strong style="color:#4caf50">Authorities</strong> (positive): many entities connect TO them. <strong style="color:#f85149">Claimers</strong> (negative): they connect to many entities but few reciprocate. The sign reveals power direction in the network.</p>
        <table><thead><tr>
          <th>Entity</th><th>Cluster</th><th>Asymmetry</th><th>Inbound</th><th>Outbound</th><th>Reciprocity</th>
        </tr></thead><tbody>
          ${byPA.map(n => `
            <tr class="clickable" onclick="switchToGraphAndSelect('${esc(n.id)}')">
              <td><strong>${esc(n.name)}</strong></td>
              <td><span class="badge badge-cluster cluster-${esc(n.cluster)}">${esc(n.cluster)}</span></td>
              <td style="color:${n.power_asymmetry > 0 ? '#4caf50' : n.power_asymmetry < -50 ? '#f85149' : '#f0ad4e'}">${n.power_asymmetry > 0 ? '+' : ''}${Math.round(n.power_asymmetry)}</td>
              <td>${n.inbound_count}</td>
              <td>${n.connection_count}</td>
              <td>${Math.round(n.reciprocity_pct)}%</td>
            </tr>
          `).join('')}
        </tbody></table>
      `;
    } else if (tab === 'density') {
      content.innerHTML = `
        <p style="color:#888;margin-bottom:8px;font-size:11px">Internal edge density per cluster. High density = entities actually interact with each other. Zero density = they share a label but are structurally isolated from each other.</p>
        <table><thead><tr>
          <th>Cluster</th><th>Density</th><th>Internal Edges</th><th>Possible Edges</th><th>Members</th><th style="width:200px">Bar</th>
        </tr></thead><tbody>
          ${densities.map(([c, v]) => `
            <tr>
              <td><span class="badge badge-cluster cluster-${esc(c)}">${esc(c)}</span></td>
              <td style="color:${v.density_pct === 0 ? '#f85149' : v.density_pct < 15 ? '#f0ad4e' : '#4caf50'}">${Math.round(v.density_pct)}%</td>
              <td>${v.internal_edges}</td>
              <td>${v.possible_edges}</td>
              <td>${v.members}</td>
              <td><div style="background:#2a2a3a;border-radius:2px;height:12px"><div style="background:${CLUSTER_COLORS[c] || '#636e72'};height:100%;width:${Math.min(100, v.density_pct)}%;border-radius:2px"></div></div></td>
            </tr>
          `).join('')}
        </tbody></table>
      `;
    } else if (tab === 'redundancy') {
      const sorted = [...pairs].sort((a, b) => a[1].bridge_count - b[1].bridge_count);
      content.innerHTML = `
        <p style="color:#888;margin-bottom:8px;font-size:11px">How many entities bridge each cluster pair? <span style="color:#f85149">SPOF (1)</span> = single point of failure. <span style="color:#f0ad4e">Fragile (2)</span> = low redundancy. <span style="color:#4caf50">Healthy (3+)</span> = resilient.</p>
        <table><thead><tr>
          <th>Cluster Pair</th><th>Bridges</th><th>Status</th><th>Bridge Entities</th>
        </tr></thead><tbody>
          ${sorted.map(([pair, v]) => {
            const [c1, c2] = pair.split('|');
            const status = v.is_spof ? 'SPOF' : v.is_fragile ? 'Fragile' : 'Healthy';
            const color = v.is_spof ? '#f85149' : v.is_fragile ? '#f0ad4e' : '#4caf50';
            return `
              <tr>
                <td><span class="badge badge-cluster cluster-${esc(c1)}">${esc(c1)}</span> → <span class="badge badge-cluster cluster-${esc(c2)}">${esc(c2)}</span></td>
                <td style="color:${color};font-weight:600">${v.bridge_count}</td>
                <td style="color:${color}">${status}</td>
                <td>${v.bridge_entities.map(e => `<span class="badge badge-cluster" style="cursor:pointer" onclick="switchToGraphAndSelect('${esc(e)}')">${entitiesData[e]?.name || e}</span>`).join(' ')}</td>
              </tr>
            `;
          }).join('')}
        </tbody></table>
      `;
    } else if (tab === 'orphans') {
      content.innerHTML = `
        <p style="color:#888;margin-bottom:8px;font-size:11px">If entity X is removed from the graph, which entities lose ALL their inbound connections? Those entities' only lifeline was through X — the infrastructure equivalent of cascading failure from removing a load balancer.</p>
        ${orphans.map(o => `
          <div style="margin-bottom:12px;padding:10px;background:#12121a;border:1px solid #2a2a3a;border-radius:4px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
              <strong style="color:#e8e8f0;cursor:pointer" onclick="switchToGraphAndSelect('${esc(o.entity)}')">${esc(o.name)}</strong>
              <span class="badge badge-cluster cluster-${esc(o.cluster)}">${esc(o.cluster)}</span>
            </div>
            <div style="color:#f85149;margin-bottom:4px">${o.orphan_count} entities would become orphans:</div>
            <div>${o.would_orphan.map(e => `<span class="badge badge-cluster cluster-${graphData._nodeMap[e]?.cluster}" style="cursor:pointer" onclick="switchToGraphAndSelect('${esc(e)}')">${entitiesData[e]?.name || e}</span>`).join(' ')}</div>
          </div>
        `).join('')}
      `;
    } else if (tab === 'affinity') {
      content.innerHTML = `
        <p style="color:#888;margin-bottom:8px;font-size:11px">Cluster affinity = % of connections within declared cluster. Low affinity means an entity's connections don't match their label — either the cluster assignment is wrong, or the entity is a cross-cluster operator.</p>
        <table><thead><tr>
          <th>Entity</th><th>Declared Cluster</th><th>Affinity</th><th>In-Cluster / Total</th><th>Bridges To</th>
        </tr></thead><tbody>
          ${[...nodes].filter(n => n.connection_count >= 2).sort((a, b) => a.cluster_affinity - b.cluster_affinity).map(n => `
            <tr class="clickable" onclick="switchToGraphAndSelect('${esc(n.id)}')">
              <td><strong>${esc(n.name)}</strong></td>
              <td><span class="badge badge-cluster cluster-${esc(n.cluster)}">${esc(n.cluster)}</span></td>
              <td style="color:${n.cluster_affinity === 0 ? '#f85149' : n.cluster_affinity < 30 ? '#f0ad4e' : '#4caf50'}">${Math.round(n.cluster_affinity)}%</td>
              <td>${Math.round(n.cluster_affinity * n.connection_count / 100)} / ${n.connection_count}</td>
              <td>${n.bridge_clusters.map(c => `<span class="badge badge-cluster cluster-${esc(c)}">${esc(c)}</span>`).join('')}</td>
            </tr>
          `).join('')}
        </tbody></table>
      `;
    } else if (tab === 'bottleneck') {
      const res = st.resilience || {};
      const bottlenecks = st.bottleneck ? [...st.bottleneck].sort((a, b) => b.score - a.score) : [];
      const spofPct = res.total_cluster_pairs > 0 ? Math.round((res.spof_pairs / res.total_cluster_pairs) * 100) : 0;
      content.innerHTML = `
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:8px;margin-bottom:12px">
          <div style="background:#12121a;border:1px solid #2a2a3a;padding:10px;border-radius:4px">
            <div style="color:#888;font-size:10px">SPOF PAIRS</div>
            <div style="color:#f85149;font-size:18px;font-weight:600">${res.spof_pairs || 0}/${res.total_cluster_pairs || 0}</div>
            <div style="color:#f85149;font-size:11px;font-weight:600">${spofPct}%</div>
          </div>
          <div style="background:#12121a;border:1px solid #2a2a3a;padding:10px;border-radius:4px">
            <div style="color:#888;font-size:10px">CASCADE ENTITIES</div>
            <div style="color:#f0ad4e;font-size:18px;font-weight:600">${res.entities_with_cascade || 0}</div>
            <div style="color:#666;font-size:10px">have cascade impact</div>
          </div>
          <div style="background:#12121a;border:1px solid #2a2a3a;padding:10px;border-radius:4px">
            <div style="color:#888;font-size:10px">TOTAL ENTITIES</div>
            <div style="color:#6ea8fe;font-size:18px;font-weight:600">${res.total_entities || 0}</div>
            <div style="color:#666;font-size:10px">in network</div>
          </div>
        </div>
        <p style="color:#888;margin-bottom:8px;font-size:11px"><strong style="color:#e8e8f0">Bottleneck score</strong> = inbound connections + (sole bridge pairs × 3) + (cascade impact × 2). High scores indicate entities whose removal would most damage the network's connectivity and cascade failures across multiple hops.</p>
        <table><thead><tr>
          <th data-sort="score">Score</th><th>Entity</th><th>Cluster</th><th>Inbound</th><th>Sole Bridge</th><th>Wave 1</th><th>Wave 2</th><th>Total Cascade</th>
        </tr></thead><tbody>
          ${bottlenecks.map(b => `
            <tr class="clickable" onclick="switchToGraphAndSelect('${esc(b.entity)}')">
              <td style="color:#f85149;font-weight:600">${b.score}</td>
              <td><strong>${esc(b.name)}</strong></td>
              <td><span class="badge badge-cluster cluster-${esc(b.cluster)}">${esc(b.cluster)}</span></td>
              <td>${b.inbound}</td>
              <td>${b.sole_bridge}</td>
              <td style="color:${b.cascade_wave1 > 0 ? '#f0ad4e' : '#666'}">${b.cascade_wave1}</td>
              <td style="color:${b.cascade_wave2 > 0 ? '#f85149' : '#666'}">${b.cascade_wave2}</td>
              <td style="color:${b.cascade_total > 0 ? '#f85149' : '#666'};font-weight:600">${b.cascade_total}</td>
            </tr>
          `).join('')}
        </tbody></table>
      `;
    }
  }

  // Tab click handlers
  dashboard.querySelectorAll('#structural-tabs .dash-filter').forEach(btn => {
    btn.addEventListener('click', () => showTab(btn.dataset.stab));
  });

  showTab('holes');
}

// ═══════════════════════════════════════════════════════════════
// VIEW SWITCHING
// ═══════════════════════════════════════════════════════════════

function switchView(view) {
  const main = document.getElementById('main');
  const graphContainer = document.getElementById('graph-container');
  const inspector = document.getElementById('inspector');
  const dashboard = document.getElementById('dashboard');
  const legend = document.getElementById('legend');

  document.querySelectorAll('nav button').forEach(b => b.classList.toggle('active', b.dataset.view === view));

  if (view === 'graph') {
    main.className = 'main graph-mode';
    graphContainer.style.display = '';
    inspector.style.display = '';
    dashboard.style.display = 'none';
    legend.style.display = '';
  } else {
    main.className = 'main dash-mode';
    graphContainer.style.display = 'none';
    inspector.style.display = 'none';
    dashboard.style.display = 'block';
    legend.style.display = 'none';
    if (view === 'dashboard') renderDashboard();
    else if (view === 'bridges') renderBridges();
    else if (view === 'cascade') renderCascade();
    else if (view === 'scatter') renderGapScatter();
    else if (view === 'chord') renderChordDiagram();
    else if (view === 'structural') renderStructural();
  }
}

document.querySelectorAll('nav button').forEach(btn => {
  btn.addEventListener('click', () => switchView(btn.dataset.view));
});

// ═══════════════════════════════════════════════════════════════
// SEARCH
// ═══════════════════════════════════════════════════════════════

document.getElementById('search').addEventListener('input', e => {
  const q = e.target.value.toLowerCase();
  if (!q) {
    window._graphNode.style('display', null);
    window._graphLink.style('display', null);
    return;
  }
  const matches = new Set(graphData.nodes.filter(n =>
    n.name.toLowerCase().includes(q) || n.id.includes(q) || n.cluster.includes(q)
  ).map(n => n.id));

  window._graphNode.style('display', n => matches.has(n.id) ? null : 'none');
  window._graphLink.style('display', l => {
    const src = l.source.id || l.source;
    const tgt = l.target.id || l.target;
    return matches.has(src) && matches.has(tgt) ? null : 'none';
  });
});

// About panel toggle
document.getElementById('about-btn').addEventListener('click', () => {
  const p = document.getElementById('about-panel');
  p.style.display = p.style.display === 'none' ? '' : 'none';
});

// Boot
loadData();
</script>
</body>
</html>
